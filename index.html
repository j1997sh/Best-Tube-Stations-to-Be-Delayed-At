<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Best Tube Station To Be Delayed At</title>

  <!-- Leaflet (map) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    :root { color-scheme: light; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: #f6f7f8;
      color: #111;
    }
    header {
      padding: 16px 18px;
      background: white;
      border-bottom: 1px solid #e6e6e6;
    }
    h1 { margin: 0 0 6px 0; font-size: 18px; }
    p.sub { margin: 0; color: #555; font-size: 13px; line-height: 1.4; }

    .wrap {
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 12px;
      padding: 12px;
    }
    @media (max-width: 900px) {
      .wrap { grid-template-columns: 1fr; }
      #map { height: 55vh !important; }
    }

    .card {
      background: white;
      border: 1px solid #e6e6e6;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 1px 0 rgba(0,0,0,0.02);
    }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    input[type="text"] {
      flex: 1;
      min-width: 180px;
      padding: 10px 12px;
      border: 1px solid #d9d9d9;
      border-radius: 10px;
      font-size: 14px;
      outline: none;
    }
    button {
      padding: 10px 12px;
      border: 1px solid #d9d9d9;
      border-radius: 10px;
      background: #111;
      color: white;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
    }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    .muted { color: #666; font-size: 12px; line-height: 1.35; }
    .kv {
      display: grid;
      grid-template-columns: 120px 1fr;
      gap: 6px 10px;
      font-size: 13px;
      margin-top: 10px;
    }
    .k { color: #666; }
    .v { color: #111; }
    .status {
      margin-top: 10px;
      max-height: 210px;
      overflow: auto;
      border: 1px solid #eee;
      border-radius: 10px;
      padding: 10px;
      background: #fafafa;
      font-size: 13px;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 9px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid #e2e2e2;
      background: #fff;
    }
    #map { height: calc(100vh - 110px); border-radius: 14px; border: 1px solid #e6e6e6; }
    .error { color: #b00020; font-size: 13px; margin-top: 8px; }
    a { color: inherit; }
    code.inline { background:#f0f0f0; padding:2px 6px; border-radius:6px; }
  </style>
</head>

<body>
<header>
  <h1>Best Tube Station To Be Delayed At</h1>
  <p class="sub">Enter a postcode ‚Üí nearest Tube station ‚Üí live line status ‚Üí closest pub. (Browser-only demo.)</p>
</header>

<div class="wrap">
  <div class="card">
    <div class="row">
      <input id="postcode" type="text" placeholder="e.g. SW1A 1AA" autocomplete="postal-code" />
      <button id="go">Find my delay pub</button>
    </div>
    <p class="muted" style="margin:10px 0 0 0;">
      Uses <b>postcodes.io</b> for geocoding, <b>TfL Unified API</b> for station + status, and <b>OpenStreetMap Overpass</b> for pubs.
      If TfL fails due to CORS, this page uses a demo proxy (<code class="inline">allorigins.win</code>).
    </p>

    <div id="chips" class="row" style="margin-top:10px;"></div>

    <div id="info" class="kv" style="display:none;">
      <div class="k">Postcode</div><div class="v" id="iPostcode"></div>
      <div class="k">Nearest station</div><div class="v" id="iStation"></div>
      <div class="k">Distance</div><div class="v" id="iDistance"></div>
      <div class="k">Closest pub</div><div class="v" id="iPub"></div>
      <div class="k">Walk-ish</div><div class="v" id="iWalk"></div>
    </div>

    <div id="statusWrap" style="display:none;">
      <div style="margin-top:12px;" class="row">
        <span class="pill">Live Tube status</span>
        <span class="muted">Lines serving the chosen station (when available)</span>
      </div>
      <div id="status" class="status"></div>
    </div>

    <div id="err" class="error" style="display:none;"></div>
  </div>

  <div id="map"></div>
</div>

<script>
/**
 * ---------- Config ----------
 * TfL endpoints (Unified API): https://api.tfl.gov.uk
 * Many browsers will block direct calls (CORS), so we wrap requests via a demo proxy.
 */
const TFL_APP_ID = "";   // optional
const TFL_APP_KEY = "";  // optional

// Demo CORS proxy (not for production)
const CORS_PROXY = (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;

const endpoints = {
  // UK postcode geocode (no key needed)
  geocode: (postcode) => `https://api.postcodes.io/postcodes/${encodeURIComponent(postcode)}`,

  // TfL StopPoint near a location
  // We'll ask for common stop types that include Tube stations.
  // Docs: TfL Unified API Swagger lists StopPoint search/nearby.
  tflStopPoint: (lat, lon, radius=1500) => {
    const base = `https://api.tfl.gov.uk/StopPoint?lat=${lat}&lon=${lon}&radius=${radius}&stopTypes=NaptanMetroStation`;
    return withTflKeys(base);
  },

  // TfL line status for all Tube lines
  tflTubeStatus: () => withTflKeys(`https://api.tfl.gov.uk/Line/Mode/tube/Status`),

  // Overpass: find pubs near station coords
  overpassPubs: (lat, lon, around=900) => {
    const q = `
      [out:json][timeout:25];
      (
        node["amenity"="pub"](around:${around},${lat},${lon});
        way["amenity"="pub"](around:${around},${lat},${lon});
        relation["amenity"="pub"](around:${around},${lat},${lon});
      );
      out center;
    `;
    return `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(q)}`;
  }
};

function withTflKeys(url) {
  const hasQ = url.includes("?");
  const params = [];
  if (TFL_APP_ID) params.push(`app_id=${encodeURIComponent(TFL_APP_ID)}`);
  if (TFL_APP_KEY) params.push(`app_key=${encodeURIComponent(TFL_APP_KEY)}`);
  if (!params.length) return url;
  return url + (hasQ ? "&" : "?") + params.join("&");
}

/**
 * ---------- Helpers ----------
 */
function $(id){ return document.getElementById(id); }

function showError(msg){
  $("err").style.display = "block";
  $("err").textContent = msg;
}
function clearError(){
  $("err").style.display = "none";
  $("err").textContent = "";
}

function setBusy(b){
  $("go").disabled = b;
  $("go").textContent = b ? "Working..." : "Find my delay pub";
}

function haversineMeters(aLat, aLon, bLat, bLon) {
  const R = 6371000;
  const toRad = (d) => d * Math.PI / 180;
  const dLat = toRad(bLat - aLat);
  const dLon = toRad(bLon - aLon);
  const s1 = Math.sin(dLat/2), s2 = Math.sin(dLon/2);
  const aa = s1*s1 + Math.cos(toRad(aLat))*Math.cos(toRad(bLat))*s2*s2;
  const c = 2 * Math.atan2(Math.sqrt(aa), Math.sqrt(1-aa));
  return R * c;
}

function prettyMeters(m){
  if (m < 1000) return `${Math.round(m)} m`;
  return `${(m/1000).toFixed(2)} km`;
}
function roughWalkTime(minMeters){
  // ~80 m/min ~= 4.8 km/h
  const mins = Math.max(1, Math.round(minMeters / 80));
  return `${mins} min`;
}

async function fetchJson(url, {useProxy=false} = {}) {
  const finalUrl = useProxy ? CORS_PROXY(url) : url;
  const res = await fetch(finalUrl, { headers: { "Accept": "application/json" } });
  if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
  return await res.json();
}

function makeChip(text){
  const el = document.createElement("span");
  el.className = "pill";
  el.textContent = text;
  return el;
}

/**
 * ---------- Map ----------
 */
const map = L.map("map").setView([51.5074, -0.1278], 12);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

let markersLayer = L.layerGroup().addTo(map);

function resetMarkers(){
  markersLayer.clearLayers();
}

function addMarker(lat, lon, label){
  const m = L.marker([lat, lon]).addTo(markersLayer);
  if (label) m.bindPopup(label);
  return m;
}

/**
 * ---------- Core flow ----------
 */
async function run() {
  clearError();
  $("info").style.display = "none";
  $("statusWrap").style.display = "none";
  $("chips").innerHTML = "";
  resetMarkers();

  const raw = $("postcode").value.trim();
  if (!raw) {
    showError("Enter a postcode first.");
    return;
  }

  setBusy(true);

  try {
    // 1) Geocode postcode
    const geo = await fetchJson(endpoints.geocode(raw));
    if (!geo || geo.status !== 200 || !geo.result) {
      throw new Error("Could not geocode that postcode.");
    }
    const { latitude: userLat, longitude: userLon, postcode } = geo.result;
    $("chips").appendChild(makeChip(`üìç ${postcode}`));

    // 2) Nearest Tube station via TfL StopPoint
    // Use proxy because TfL frequently fails CORS in browsers.
    const stopData = await fetchJson(endpoints.tflStopPoint(userLat, userLon, 2000), { useProxy: true });
    const stops = (stopData && stopData.stopPoints) ? stopData.stopPoints : [];
    if (!stops.length) throw new Error("No nearby Tube stations found (within ~2km). Try another postcode.");

    // Pick closest by lat/lon distance
    const sorted = stops
      .filter(s => typeof s.lat === "number" && typeof s.lon === "number")
      .map(s => ({ s, d: haversineMeters(userLat, userLon, s.lat, s.lon) }))
      .sort((a,b) => a.d - b.d);

    const station = sorted[0].s;
    const stationDist = sorted[0].d;

    $("chips").appendChild(makeChip("üöá Nearest station found"));

    // 3) Find closest pub near station using Overpass
    const over = await fetchJson(endpoints.overpassPubs(station.lat, station.lon, 1000));
    const els = (over && over.elements) ? over.elements : [];
    if (!els.length) throw new Error("No pubs found within ~1km of that station (surprisingly).");

    // Normalize pub points (node: lat/lon, way/relation: center)
    const pubs = els.map(e => {
      const lat = e.lat ?? (e.center && e.center.lat);
      const lon = e.lon ?? (e.center && e.center.lon);
      const name = (e.tags && e.tags.name) ? e.tags.name : "Unnamed pub";
      return (typeof lat === "number" && typeof lon === "number")
        ? { lat, lon, name, osmId: `${e.type}/${e.id}` }
        : null;
    }).filter(Boolean);

    pubs.sort((a,b) =>
      haversineMeters(station.lat, station.lon, a.lat, a.lon) -
      haversineMeters(station.lat, station.lon, b.lat, b.lon)
    );

    const pub = pubs[0];
    const pubDist = haversineMeters(station.lat, station.lon, pub.lat, pub.lon);

    $("chips").appendChild(makeChip("üç∫ Closest pub found"));

    // 4) Tube line status (live)
    // We‚Äôll fetch overall tube status and then filter to lines that appear to serve this station if possible.
    const tubeStatus = await fetchJson(endpoints.tflTubeStatus(), { useProxy: true });

    // Attempt: station.lines may exist as array of lines with id/name
    const stationLineIds = (station.lines || []).map(l => l.id).filter(Boolean);
    let relevant = tubeStatus;

    if (Array.isArray(tubeStatus) && stationLineIds.length) {
      relevant = tubeStatus.filter(line => stationLineIds.includes(line.id));
    }

    // Render
    $("iPostcode").textContent = postcode;
    $("iStation").innerHTML = `${escapeHtml(station.commonName || "Unknown station")} <span class="muted">(${escapeHtml(station.naptanId || "")})</span>`;
    $("iDistance").textContent = `${prettyMeters(stationDist)} from postcode`;
    $("iPub").textContent = `${pub.name}`;
    $("iWalk").textContent = `${prettyMeters(pubDist)} (~${roughWalkTime(pubDist)}) from station`;
    $("info").style.display = "grid";

    // Status box
    $("status").innerHTML = renderStatus(relevant, stationLineIds.length ? "Lines at this station" : "All Tube lines (station lines unavailable)");
    $("statusWrap").style.display = "block";

    // Map markers
    const userM = addMarker(userLat, userLon, `<b>Your postcode</b><br>${escapeHtml(postcode)}`);
    const stationM = addMarker(station.lat, station.lon, `<b>${escapeHtml(station.commonName || "Tube station")}</b><br>${prettyMeters(stationDist)} away`);
    const pubM = addMarker(pub.lat, pub.lon, `<b>${escapeHtml(pub.name)}</b><br>${prettyMeters(pubDist)} from station`);

    // Fit bounds
    const group = L.featureGroup([userM, stationM, pubM]);
    map.fitBounds(group.getBounds().pad(0.25));

    // A ‚Äúbest place to be delayed‚Äù gag score:
    // More disruption + closer pub => ‚Äúbetter‚Äù
    const disruptionScore = estimateDisruptionScore(relevant);
    const delayVibes = Math.round((disruptionScore * 10) + Math.max(0, 10 - Math.min(10, pubDist / 150)));
    $("chips").appendChild(makeChip(`‚è±Ô∏è Delay vibes: ${delayVibes}/25`));

  } catch (e) {
    showError(e.message || String(e));
  } finally {
    setBusy(false);
  }
}

function escapeHtml(str){
  return String(str).replace(/[&<>"']/g, s => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[s]));
}

function renderStatus(statusData, title){
  if (!Array.isArray(statusData) || !statusData.length) {
    return `<div class="muted">No status data returned.</div>`;
  }
  const lines = statusData.map(line => {
    const name = line.name || line.id || "Unknown line";
    const statuses = (line.lineStatuses || []).map(ls => ls.statusSeverityDescription || "Unknown").join(", ") || "Unknown";
    const reason = (line.lineStatuses || []).map(ls => ls.reason).filter(Boolean)[0] || "";
    return `
      <div style="padding:8px 6px; border-bottom:1px solid #eee;">
        <div><b>${escapeHtml(name)}</b> ‚Äî ${escapeHtml(statuses)}</div>
        ${reason ? `<div class="muted">${escapeHtml(reason)}</div>` : ``}
      </div>
    `;
  }).join("");

  return `<div class="muted" style="margin-bottom:8px;"><b>${escapeHtml(title)}</b></div>${lines}`;
}

function estimateDisruptionScore(statusData){
  // crude: count anything not ‚ÄúGood Service‚Äù
  if (!Array.isArray(statusData)) return 0;
  let bad = 0;
  for (const line of statusData) {
    const s = (line.lineStatuses || [])[0];
    const desc = (s && s.statusSeverityDescription) ? s.statusSeverityDescription.toLowerCase() : "";
    if (desc && !desc.includes("good service")) bad += 1;
  }
  return bad;
}

// UI
$("go").addEventListener("click", run);
$("postcode").addEventListener("keydown", (e) => { if (e.key === "Enter") run(); });
</script>
</body>
</html>
