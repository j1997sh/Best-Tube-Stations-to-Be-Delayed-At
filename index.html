<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Where Am I? Tube Delays + Closest Pub + Wetherspoons</title>

  <!-- Leaflet (map) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    :root { color-scheme: light dark; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0;
      padding: 0;
      line-height: 1.35;
    }
    header {
      padding: 16px 16px 8px;
      border-bottom: 1px solid rgba(127,127,127,.25);
    }
    h1 { margin: 0 0 8px; font-size: 18px; }
    .sub { opacity: .8; font-size: 13px; margin: 0 0 12px; }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 8px 0 0;
    }
    button {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(127,127,127,.35);
      background: rgba(127,127,127,.12);
      cursor: pointer;
      font-weight: 600;
    }
    button:disabled { opacity: .5; cursor: not-allowed; }
    main {
      display: grid;
      grid-template-columns: 1.1fr .9fr;
      gap: 12px;
      padding: 12px 16px 16px;
    }
    #map { height: 70vh; min-height: 420px; border-radius: 14px; overflow: hidden; }
    .panel {
      border: 1px solid rgba(127,127,127,.25);
      border-radius: 14px;
      padding: 12px;
      background: rgba(127,127,127,.06);
      overflow: auto;
      max-height: 70vh;
    }
    .card {
      border: 1px solid rgba(127,127,127,.25);
      border-radius: 12px;
      padding: 10px;
      margin: 10px 0;
      background: rgba(127,127,127,.06);
    }
    .row { display: flex; justify-content: space-between; gap: 8px; flex-wrap: wrap; }
    .muted { opacity: .8; font-size: 13px; }
    .ok { color: #1b8f3a; font-weight: 700; }
    .bad { color: #c0352b; font-weight: 800; }
    .warn { color: #b97a00; font-weight: 800; }
    a { color: inherit; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    @media (max-width: 900px) {
      main { grid-template-columns: 1fr; }
      #map, .panel { max-height: none; height: 55vh; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Tube delays + closest pub + closest Wetherspoons</h1>
    <p class="sub">
      Uses your device location (with permission), TfL line status, and OpenStreetMap to find nearby pubs.
    </p>

    <div class="controls">
      <button id="btnLocate">üìç Get my location</button>
      <button id="btnRefresh" disabled>üîÑ Refresh all</button>
      <button id="btnFollow" disabled>üß≠ Follow me (watch)</button>
      <button id="btnStopWatch" disabled>üõë Stop watch</button>
    </div>

    <p id="status" class="muted" style="margin: 10px 0 0;"></p>
  </header>

  <main>
    <div id="map"></div>

    <div class="panel">
      <div class="card">
        <div class="row">
          <strong>Your location</strong>
          <span id="coords" class="muted">‚Äî</span>
        </div>
        <div id="address" class="muted" style="margin-top: 6px;">‚Äî</div>
      </div>

      <div class="card">
        <strong>Closest places</strong>
        <div id="closestResults" class="muted" style="margin-top: 8px;">‚Äî</div>
      </div>

      <div class="card">
        <div class="row">
          <strong>Tube status (TfL)</strong>
          <span class="muted" id="tflUpdated">‚Äî</span>
        </div>
        <div id="tubeStatus" class="muted" style="margin-top: 8px;">‚Äî</div>
      </div>

      <div class="card">
        <strong>Debug</strong>
        <div class="muted">
          If geolocation doesn‚Äôt work, ensure you‚Äôre on <code>https://</code> or <code>http://localhost</code>.
          If pubs fail, Overpass may be rate-limiting; wait ~30 seconds and refresh.
        </div>
      </div>
    </div>
  </main>

  <script>
    // ---------------------------
    // Helpers
    // ---------------------------
    const $ = (id) => document.getElementById(id);

    function setStatus(msg) {
      $("status").textContent = msg;
    }

    function haversineMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000; // meters
      const toRad = (d) => d * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat/2) ** 2 +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function fmtDistance(m) {
      if (m < 1000) return `${Math.round(m)} m`;
      return `${(m / 1000).toFixed(2)} km`;
    }

    function directionsLink(lat, lon) {
      return `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(lat + "," + lon)}&travelmode=walking`;
    }

    function safeText(v) {
      return (v === null || v === undefined || v === "") ? "‚Äî" : String(v);
    }

    // ---------------------------
    // Map setup
    // ---------------------------
    const map = L.map("map").setView([51.5074, -0.1278], 12); // default London
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    let meMarker = null;
    let pubMarker = null;
    let spoonsMarker = null;
    let watchId = null;

    function putMarker(existing, lat, lon, label) {
      if (existing) map.removeLayer(existing);
      const m = L.marker([lat, lon]).addTo(map).bindPopup(label);
      return m;
    }

    // ---------------------------
    // Data fetchers
    // ---------------------------
    async function reverseGeocode(lat, lon) {
      const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}`;
      const res = await fetch(url, { headers: { "Accept": "application/json" } });
      if (!res.ok) throw new Error(`Reverse geocode failed: ${res.status}`);
      return await res.json();
    }

    async function fetchTubeStatus() {
      const url = "https://api.tfl.gov.uk/Line/Mode/tube/Status";
      const res = await fetch(url, { headers: { "Accept": "application/json" } });
      if (!res.ok) throw new Error(`TfL status failed: ${res.status}`);
      return await res.json();
    }

    // IMPORTANT: Overpass is often rate-limited. We:
    // - try multiple endpoints
    // - enforce a timeout
    // - show a friendly error when all fail
    async function overpassQuery(query) {
      const endpoints = [
        "https://overpass-api.de/api/interpreter",
        "https://overpass.kumi.systems/api/interpreter",
        "https://overpass.openstreetmap.ru/api/interpreter",
        "https://lz4.overpass-api.de/api/interpreter"
      ];

      const timeoutMs = 15000;
      let lastErr = null;

      for (const url of endpoints) {
        const controller = new AbortController();
        const t = setTimeout(() => controller.abort(), timeoutMs);

        try {
          const res = await fetch(url, {
            method: "POST",
            body: query,
            headers: { "Content-Type": "text/plain;charset=UTF-8" },
            signal: controller.signal
          });

          clearTimeout(t);

          if (!res.ok) {
            const msg = await res.text().catch(() => "");
            throw new Error(`Overpass ${res.status} from ${url}${msg ? " ‚Äî " + msg.slice(0, 120) : ""}`);
          }

          return await res.json();
        } catch (e) {
          clearTimeout(t);
          lastErr = e;
          console.warn("Overpass failed, trying next endpoint:", url, e);
        }
      }

      throw lastErr || new Error("All Overpass endpoints failed.");
    }

    async function findNearbyPubs(lat, lon) {
      // Smaller radius reduces timeouts and payload sizes
      const radius = 1500;

      const q = `
[out:json][timeout:25];
(
  node(around:${radius},${lat},${lon})["amenity"="pub"];
  way(around:${radius},${lat},${lon})["amenity"="pub"];
  relation(around:${radius},${lat},${lon})["amenity"="pub"];

  node(around:${radius},${lat},${lon})["name"~"wetherspoon|jd wetherspoon|wetherspoons","i"];
  way(around:${radius},${lat},${lon})["name"~"wetherspoon|jd wetherspoon|wetherspoons","i"];
  relation(around:${radius},${lat},${lon})["name"~"wetherspoon|jd wetherspoon|wetherspoons","i"];
);
out center tags;
      `.trim();

      return await overpassQuery(q);
    }

    function extractElementLatLon(el) {
      if (el.type === "node") return { lat: el.lat, lon: el.lon };
      if (el.center) return { lat: el.center.lat, lon: el.center.lon };
      return null;
    }

    function pickClosest(elements, lat, lon, predicateFn) {
      let best = null;

      for (const el of elements) {
        const pos = extractElementLatLon(el);
        if (!pos) continue;

        const tags = el.tags || {};
        if (predicateFn && !predicateFn(tags)) continue;

        const d = haversineMeters(lat, lon, pos.lat, pos.lon);
        if (!best || d < best.distanceMeters) {
          best = {
            id: `${el.type}/${el.id}`,
            name: tags.name || tags.brand || "Unnamed place",
            lat: pos.lat,
            lon: pos.lon,
            distanceMeters: d,
            tags
          };
        }
      }
      return best;
    }

    // ---------------------------
    // Renderers
    // ---------------------------
    function renderTubeStatus(lines) {
      const mapped = lines.map(l => {
        const statuses = (l.lineStatuses || []).map(s => s.statusSeverityDescription).filter(Boolean);
        const unique = [...new Set(statuses)];
        const worst = unique.find(x => x !== "Good Service") || "Good Service";
        return { name: l.name, status: worst, details: unique.join(", ") };
      });

      mapped.sort((a, b) => {
        const aBad = a.status !== "Good Service";
        const bBad = b.status !== "Good Service";
        if (aBad !== bBad) return aBad ? -1 : 1;
        return a.name.localeCompare(b.name);
      });

      const html = mapped.map(x => {
        const s = x.status.toLowerCase();
        const cls = x.status === "Good Service" ? "ok" : (s.includes("minor") ? "warn" : "bad");
        return `
          <div class="row" style="margin: 6px 0;">
            <span><strong>${x.name}</strong></span>
            <span class="${cls}">${x.status}</span>
          </div>
        `;
      }).join("");

      $("tubeStatus").innerHTML = html || "No status available.";
      $("tflUpdated").textContent = new Date().toLocaleString();
    }

    function renderClosest(closestPub, closestSpoons) {
      const parts = [];

      if (closestPub) {
        parts.push(`
          <div style="margin-bottom: 10px;">
            <div><strong>Closest pub</strong>: ${safeText(closestPub.name)}</div>
            <div class="muted">Distance: ${fmtDistance(closestPub.distanceMeters)}</div>
            <div class="muted"><a href="${directionsLink(closestPub.lat, closestPub.lon)}" target="_blank" rel="noreferrer">Walking directions</a></div>
          </div>
        `);
      } else {
        parts.push(`<div><strong>Closest pub</strong>: ‚Äî</div>`);
      }

      if (closestSpoons) {
        parts.push(`
          <div>
            <div><strong>Closest Wetherspoons</strong>: ${safeText(closestSpoons.name)}</div>
            <div class="muted">Distance: ${fmtDistance(closestSpoons.distanceMeters)}</div>
            <div class="muted"><a href="${directionsLink(closestSpoons.lat, closestSpoons.lon)}" target="_blank" rel="noreferrer">Walking directions</a></div>
          </div>
        `);
      } else {
        parts.push(`<div style="margin-top: 6px;"><strong>Closest Wetherspoons</strong>: ‚Äî (none found nearby)</div>`);
      }

      $("closestResults").innerHTML = parts.join("");
    }

    // ---------------------------
    // Main flow
    // ---------------------------
    let lastPlacesFetchAt = 0; // cooldown timer for Overpass calls

    async function refreshAll(lat, lon, accuracyMeters) {
      $("btnRefresh").disabled = true;
      setStatus("Refreshing: reverse geocode, nearby pubs, and TfL status‚Ä¶");

      $("coords").textContent = `${lat.toFixed(6)}, ${lon.toFixed(6)}${accuracyMeters ? ` (¬±${Math.round(accuracyMeters)}m)` : ""}`;

      // marker for you
      meMarker = putMarker(meMarker, lat, lon, "You are here");
      map.setView([lat, lon], 15);

      // Reverse geocode
      try {
        const geo = await reverseGeocode(lat, lon);
        $("address").textContent = geo.display_name ? geo.display_name : "‚Äî";
      } catch (e) {
        $("address").textContent = "Reverse geocode failed (rate limit or network).";
        console.warn(e);
      }

      // Nearby places (Overpass) - cooldown to avoid rate limit
      try {
        const now = Date.now();
        const allowPlacesFetch = (now - lastPlacesFetchAt) > 30000; // 30s

        if (!allowPlacesFetch) {
          const wait = Math.ceil((30000 - (now - lastPlacesFetchAt)) / 1000);
          $("closestResults").textContent = `Waiting ${wait}s before next pub lookup (avoiding Overpass rate limits)‚Ä¶`;
        } else {
          lastPlacesFetchAt = now;
          $("closestResults").textContent = "Looking up nearby pubs‚Ä¶";

          const data = await findNearbyPubs(lat, lon);
          const els = data.elements || [];

          const closestPub = pickClosest(els, lat, lon, (tags) => tags.amenity === "pub");

          // Wetherspoons matching: name OR operator/brand hints (more robust)
          const closestSpoons = pickClosest(els, lat, lon, (tags) => {
            const n = (tags.name || "").toLowerCase();
            const b = (tags.brand || "").toLowerCase();
            const o = (tags.operator || "").toLowerCase();
            const hit =
              n.includes("wetherspoon") || n.includes("wetherspoons") || n.includes("jd wetherspoon") ||
              b.includes("wetherspoon") || b.includes("wetherspoons") || b.includes("jd wetherspoon") ||
              o.includes("wetherspoon") || o.includes("wetherspoons") || o.includes("jd wetherspoon");
            return hit;
          });

          renderClosest(closestPub, closestSpoons);

          if (closestPub) pubMarker = putMarker(pubMarker, closestPub.lat, closestPub.lon, `Closest pub: ${closestPub.name}`);
          if (closestSpoons) spoonsMarker = putMarker(spoonsMarker, closestSpoons.lat, closestSpoons.lon, `Closest Wetherspoons: ${closestSpoons.name}`);
        }
      } catch (e) {
        $("closestResults").textContent = "Nearby pub search failed (Overpass busy / rate-limited). Wait ~30s and refresh.";
        console.warn(e);
      }

      // Tube status
      try {
        const lines = await fetchTubeStatus();
        renderTubeStatus(lines);
      } catch (e) {
        $("tubeStatus").textContent = "TfL status failed (network/CORS).";
        console.warn(e);
      }

      setStatus("Done.");
      $("btnRefresh").disabled = false;
    }

    function getLocationOnce() {
      if (!navigator.geolocation) {
        setStatus("Geolocation is not supported by your browser.");
        return;
      }
      setStatus("Requesting location permission‚Ä¶");

      navigator.geolocation.getCurrentPosition(
        async (pos) => {
          const { latitude, longitude, accuracy } = pos.coords;
          $("btnRefresh").disabled = false;
          $("btnFollow").disabled = false;
          await refreshAll(latitude, longitude, accuracy);
        },
        (err) => {
          setStatus(`Location error: ${err.message}`);
          console.warn(err);
        },
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 30000 }
      );
    }

    function startWatch() {
      if (!navigator.geolocation) return;
      if (watchId !== null) return;

      setStatus("Watching location‚Ä¶ (pub lookup is throttled to avoid rate limits)");
      $("btnStopWatch").disabled = false;

      watchId = navigator.geolocation.watchPosition(
        async (pos) => {
          const { latitude, longitude, accuracy } = pos.coords;
          $("btnRefresh").disabled = false;
          await refreshAll(latitude, longitude, accuracy);
        },
        (err) => {
          setStatus(`Watch error: ${err.message}`);
          console.warn(err);
        },
        { enableHighAccuracy: true, maximumAge: 10000, timeout: 20000 }
      );
    }

    function stopWatch() {
      if (watchId === null) return;
      navigator.geolocation.clearWatch(watchId);
      watchId = null;
      setStatus("Stopped watching location.");
      $("btnStopWatch").disabled = true;
    }

    // ---------------------------
    // UI bindings
    // ---------------------------
    $("btnLocate").addEventListener("click", getLocationOnce);

    $("btnRefresh").addEventListener("click", () => {
      if (!meMarker) return;
      const { lat, lng } = meMarker.getLatLng();
      refreshAll(lat, lng, 0);
    });

    $("btnFollow").addEventListener("click", startWatch);
    $("btnStopWatch").addEventListener("click", stopWatch);

    setStatus("Click ‚ÄúGet my location‚Äù to begin.");
  </script>
</body>
</html>
